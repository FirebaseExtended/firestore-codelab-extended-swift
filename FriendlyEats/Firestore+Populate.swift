//
//  Copyright (c) 2018 Google Inc.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import FirebaseFirestore

extension Firestore {

  /// Returns a reference to the top-level users collection.
  var users: CollectionReference {
    return self.collection("users")
  }

  /// Returns a reference to the top-level restaurants collection.
  var restaurants: CollectionReference {
    return self.collection("restaurants")
  }

  /// Returns a reference to the top-level reviews collection.
  var reviews: CollectionReference {
    return self.collection("reviews")
  }

  /// Returns a reference to the yums collection for a specific restaurant.
  func yums(forReview reviewID: String) -> CollectionReference {
    return self.collection("reviews/\(reviewID)/yums")
  }

}

// MARK: Write operations

extension Firestore {

  /// Writes a user to the top-level users collection, overwriting data if the
  /// user's uid already exists in the collection.
  func add(user: User) {
    self.users.document(user.documentID).setData(user.documentData)
  }

  /// Writes a restaurant to the top-level restaurants collection, overwriting data
  /// if the restaurant's ID already exists.
  func add(restaurant: Restaurant) {
    self.restaurants.document(restaurant.documentID).setData(restaurant.documentData)
  }

  /// Writes a review to the top-level reviews collection, overwriting data if the review
  /// already exists.
  func add(review: Review) {
    self.reviews.document(review.documentID).setData(review.documentData)
  }

  /// Writes a yum to the yums subcollection for a specific review.
  func add(yum: Yum, forReview reviewID: String) {
    self.yums(forReview: reviewID).document(yum.documentID).setData(yum.documentData)
  }

}

extension WriteBatch {

  /// Writes a user to the top-level users collection, overwriting data if the
  /// user's uid already exists in the collection.
  func add(user: User) {
    let document = Firestore.firestore().users.document(user.documentID)
    self.setData(user.documentData, forDocument: document)
  }

  /// Writes a restaurant to the top-level restaurants collection, overwriting data
  /// if the restaurant's ID already exists.
  func add(restaurant: Restaurant) {
    let document = Firestore.firestore().restaurants.document(restaurant.documentID)
    self.setData(restaurant.documentData, forDocument: document)
  }

  /// Writes a review to the top-level reviews collection, overwriting data if the review
  /// already exists.
  func add(review: Review) {
    let document = Firestore.firestore().reviews.document(review.documentID)
    self.setData(review.documentData, forDocument: document)
  }

  /// Writes a yum to the yums subcollection for a specific review.
  func add(yum: Yum, toReview: String) {
    let document = Firestore.firestore().reviews.document(toReview).collection("yums").document(yum.documentID)
    self.setData(yum.documentData, forDocument: document)
  }

}

// MARK: Pre-populating Firestore data

extension Firestore {

  /// Returns a tuple of arrays containing sample data to populate the app.
  func sampleData() -> (users: [User], restaurants: [Restaurant], reviews: [Review], yums: [(String, Yum)]) {
    let userCount = 15
    let restaurantCount = 15
    let reviewCountPerRestaurant = 3

    // This must be less than or equal to the number of users,
    // since yums are unique per user per review. If this number
    // exceeds the number of users, the code will likely crash
    // when generating likes.
    let maxYumCountPerReview = 3


    // Users must be created first, since Restaurants have dependencies on users,
    // Reviews depend on both Users and Restaurants, and Yums depend on Reviews and Users.
    // The users generated here will not be backed by real users in Auth, but that's ok.
    // User IDs aren't generated by Firestore, since in the real app they'll be pulled from
    // an authentication provider (like Firebase Auth) instead of being generated.
    let users: [User] = (0 ..< userCount).map { _ in
      let uid = UUID().uuidString
      return User(userID: uid)
    }

    func randomUser() -> User { return users[Int(arc4random_uniform(UInt32(userCount)))] }

    var restaurants: [Restaurant] = (0 ..< restaurantCount).map { _ in
      let ownerID = randomUser().userID
      let name = Restaurant.randomName()
      let category = Restaurant.randomCategory()
      let city = Restaurant.randomCity()
      let price = Restaurant.randomPrice()
      let photoURL = Restaurant.randomPhotoURL()

      return Restaurant(ownerID: ownerID,
                        name: name,
                        category: category,
                        city: city,
                        price: price,
                        reviewCount: 0,   // This is modified later when generating reviews.
                        averageRating: 0, // This is modified later when generating reviews.
                        photoURL: photoURL)
    }

    var reviews: [Review] = []
    for i in 0 ..< restaurants.count {
      var restaurant = restaurants[i]
      reviews += (0 ..< reviewCountPerRestaurant).map { _ in
        let rating = RandomUniform(5) + 1
        let reviewNum = RandomUniform(3) + 1
        let userInfo = randomUser()
        let text: String
        let date = Date()
        let restaurantID = restaurant.documentID

        switch (rating, reviewNum) {
        case (5, 3):
          text = "Amazing!!"
        case (5, 2):
          text = "This was my favorite meal ever!!"
        case (5, 1):
          text = "Great service, great food. This is my new favorite restaurant !"
        case (4, 3):
          text = "Tasty restaurant, would recommend"
        case (4, 2):
          text = "Really good food for the price"
        case (4, 1):
          text = "I'd come back here again."
        case (3, 3):
          text = "Food was good but the service was slow"
        case (3, 2):
          text = "Pretty average. Nothing to write home about."
        case (3, 1):
          text = "It was a decent meal, but nothing too memorable."
        case (2, 3):
          text = "The ketchup was too spicy"
        case (2, 2):
          text = "The food was cold when it came out"
        case (2, 1):
          text = "The service was rude."
        case (1, 3):
          text = "There was a bug in my soup"
        case (1, 2):
          text = "I'd rather eat a shoe than another meal here."
        case (1, 1):
          text = "Food was bad, service was slow, place was too loud."
        case _:
          fatalError("Unreachable code. If the app breaks here, check the call to RandomUniform above.")
        }

        // Compute the new average after the review is created. This adds side effects to the map
        // statement, angering programmers all over the world
        restaurant.averageRating =
          (restaurant.averageRating * Double(restaurant.reviewCount) + Double(rating))
          / Double(restaurant.reviewCount + 1)
        restaurant.reviewCount += 1

        // Since everything here is value types, we need to explicitly write back to the array.
        restaurants[i] = restaurant

        return Review(restaurantID: restaurantID,
                      rating: rating,
                      userInfo: userInfo,
                      text: text,
                      date: date,
                      yumCount: 0) // This will be modified later when generating Yums.
      }
    }

    var yums: [(String, Yum)] = []
    for i in 0 ..< reviews.count {
      var review = reviews[i]
      let numYums = RandomUniform(maxYumCountPerReview)
      if numYums == 0 { continue }

      yums += (0 ..< numYums).map { index in
        let reviewID = review.documentID

        // index is guaranteed to be less than the number of users.
        // Use an index here instead of a random users so users don't
        // double-like restaurants, since that's supposed to be illegal.
        let userID = users[index].userID
        let userName = users[index].name

        review.yumCount += 1
        reviews[i] = review

        return (reviewID, Yum(documentID: userID, userName: userName))
      }
    }

    return (
      users: users,
      restaurants: restaurants,
      reviews: reviews,
      yums: yums
    )
  }

  // Writes data directly to the Firestore root. Useful for populating the app with sample data.
  func prepopulate(users: [User], restaurants: [Restaurant], reviews: [Review], yums: [(String, Yum)]) {
    let batch = self.batch()

    users.forEach { batch.add(user: $0) }
    restaurants.forEach { batch.add(restaurant: $0) }
    reviews.forEach { batch.add(review: $0) }
    yums.forEach { tuple in
      let restaurantID = tuple.0
      let yum = tuple.1
      batch.add(yum: yum, toReview: restaurantID)
    }

    batch.commit { error in
      if let error = error {
        print("Error populating Firestore: \(error)")
      } else {
        print("Batch committed!")
      }
    }
  }

  // Pre-populates the app with sample data.
  func prepopulate() {
    let data = sampleData()
    prepopulate(users: data.users,
                restaurants: data.restaurants,
                reviews: data.reviews,
                yums: data.yums)
  }

}
